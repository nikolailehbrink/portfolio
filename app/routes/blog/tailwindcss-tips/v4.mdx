import cover from "./tailwindcss-tips.webp";
import Alert from "@/components/Alert";
import ProfileBadge from "@/components/ProfileBadge";
import GradientHeading from "./GradientHeading";
import BreakoutSection from "./BreakoutSection";
import NewsletterForm from "@/components/NewsletterForm";

export const handle = {
  title: "Tailwind CSS v4 tips every developer should know",
  description:
    "Looking for ways to improve your development with Tailwind CSS v4? Discover tips and tricks from workflow optimizations to common design patterns.",
  publicationDate: "2025-07-08",
  authors: ["Nikolai Lehbrink"],
  tags: ["Tailwind CSS", "Tips and Tricks"],
  cover,
  readingTime: 12,
};

Over the past years, I've used Tailwind CSS in almost every web project I've undertaken. Along the way, I've picked up a few handy tips and tricks that I'd like to share.

<Alert type="question" heading="Do you still use Tailwind CSS v3?">
  The old version of this post for [Tailwind CSS
  v3](https://v3.tailwindcss.com/) is available
  [here](/blog/tailwindcss-v3-tips).
</Alert>

Please do not hesitate to [get in touch with me](/#contact) if you have a tip that you think I should include.

## Common Practices

Some scenarios that many people have probably encountered.

### Targeting a single breakpoint

Sometimes you wan't to style an element only for a specific breakpoint. I ended up writing classes, that targeted multiple breakpoints, only to style one in particular.

```html
<div class="bg-red-500 sm:bg-green-500 md:bg-red-500">
  <!-- ... -->
</div>
```

However with the [release of Tailwind CSS v3.2](https://tailwindcss.com/blog/tailwindcss-v3-2) and the [implementation of dynamic breakpoints](https://tailwindcss.com/blog/tailwindcss-v3-2#max-width-and-dynamic-breakpoints) it is much easier to target a single breakpoint now.

You can stack responsive modifiers and achieve the same result with only one class selector.

```html remove=1 add=2 showLineNumbers=4 /sm:max-xl:bg-green-500/
<div class="bg-red-500 sm:bg-green-500 md:bg-red-500">
<div class="bg-red-500 sm:max-xl:bg-green-500">
  <!-- ... -->
</div>
```

<Alert type="tip">The same logic applies to breakpoint ranges.</Alert>

### Targeting Elements Not Included in Your Initial Markup

Almost inevitable, you will encounter scenarios where some elements are not directly accessible in your static HTML markup because they are added during the build process or dynamically through JavaScript.

<Alert type="question" heading="When is this ever going to happen?">
  This often occurs with content generated by third-party tools or libraries.
</Alert>

For example, I use a syntax highlighter called [`Shiki`](https://shiki.style/), which generates the blocks of code you see on this page. They are wrapped in `<pre>{:html}` and `<code>{:html}` tags and these elements still require styling to ensure they align with the overall design of the site.

Here are two possible ways of dealing with this situation.

#### Use the `@apply{:css}` directive

You can use [`@apply{:css}`](https://tailwindcss.com/docs/functions-and-directives#apply) to inline any existing utility classes into your own custom CSS.

```postcss /@apply/ filename="app.css" {3,5}
.shiki {
  pre {
    @apply scrollbar-thin overflow-x-auto bg-neutral-900;
    code {
      @apply block w-fit min-w-full;
    }
  }
}
```

#### Use arbitrary variants

With the implementation of [arbitrary variants](https://tailwindcss.com/docs/hover-focus-and-other-states#using-arbitrary-variants) in [Tailwind CSS v3.1](https://tailwindcss.com/blog/tailwindcss-v3-1) it is possible to create custom variants directly in your HTML.

```html {1}
<div class="[&>pre]:overflow-x-auto [&_code]:block ...">
  <!-- <pre>
    <code>
      ...
    </code>
  </pre> -->
</div>
```

<Alert type="question" heading="Which selectors do the classes address?">
  In this example, the selector `[&_code]` targets all `<code>{:html}` child elements and `[&>pre]` specifically targets `<pre>{:html}` elements that are direct children of the surrounding `<div>{:html}`.
</Alert>

### Customise containers with standard padding and autocentering

Often times in web design, we do not wan't to scale or fit content to the outermost width of the viewport but rather have content inside a container which helps usability and helps the user to focus on the important part of the site.

The [`container` class](https://tailwindcss.com/docs/max-width#using-breakpoints-container) in Tailwind CSS can be used to achieve just that, applying a `max-width` to the specific element.

<Alert type="tip">
  A common case is centering the container on the page with side padding to keep
  content away from the viewport edges, especially on mobile devices.
</Alert>

```html
<div class="container mx-auto px-4 sm:px-8 lg:px-16">
  <!-- ... -->
</div>
```

The code above achieves that functionality, but always having to centre the container yourself with the `mx-auto` class and specify your own padding can lead to inconsistencies and is a rather tedious task. That's why in Tailwind CSS v4, you can now adjust the `container` utility directly with CSS:

```css filename="app.css"
@utility container {
  @apply mx-auto px-4 sm:px-8 lg:px-16;
}
```

This centers your container and adds consistent horizontal padding, all with a simple utility override.

<NewsletterForm />

Now, simply use the `container` class and have the same result, without any further code.

```html /container/ add=2 remove=1
<div class="container mx-auto px-4 sm:px-8 lg:px-16">
<div class="container">
  <!-- ... -->
</div>
```

### Using theme values in JavaScript

In Tailwind CSS v3, you could use the `resolveConfig` function to access your theme values directly in JavaScript. In v4, this approach has changed: **Tailwind now generates CSS variables for your theme values**, making it much easier (and more efficient) to use them in your code.

Instead of importing and resolving your config, you can reference these CSS variables directly. For example, with [Chakra UI](https://chakra-ui.com/), you can style a component using a Tailwind theme color like this:

```jsx filename="Example.jsx"
import { Box } from "@chakra-ui/react";

<Box sx={{ backgroundColor: "var(--color-emerald-500)" }}>
  Themed with Tailwind CSS variable!
</Box>;
```

If you need to access the _resolved value_ of a CSS variable in JavaScript, you can use `getComputedStyle` on the `document.documentElement`:

```js filename="spaghetti.js"
let styles = getComputedStyle(document.documentElement);
let shadow = styles.getPropertyValue("--shadow-xl");
```

This new approach is simpler and helps reduce your bundle size, since you no longer need to import or resolve your Tailwind config in your application code.

### Setting width and height in one go

Often, when browsing through tutorials on YouTube or other websites, you'll notice that many developers apply width and height classes separately to achieve square dimensions for elements like icons or avatars.

With the introduction of the `size-*` utilities in [Tailwind CSS v3.4](https://tailwindcss.com/blog/tailwindcss-v3-4#new-size-utilities), setting both dimensions simultaneously has become much more straightforward.

```html remove=1 add=2 /size-12/
<div class="h-12 w-12 bg-red-500">
<div class="size-12 bg-red-500">
  <!-- ... -->
</div>
```

## Optimize Development

Tips that should make your development with Tailwind CSS v4 easier.

### Automatic wrapping of long class names

With Tailwind CSS it is almost impossible to avoid writing long class names for certain elements. This should not be a problem, but the class names remain on one line and are not, for example, formatted and limited in length by Prettier and split over several lines. This means that developers often have to scroll horizontally for some time to find the right class.

<Alert>
  The problem is so significant that it is [rated as the top idea for Tailwind
  CSS on
  GitHub](https://github.com/tailwindlabs/tailwindcss/discussions?discussions_q=is%3Aopen+sort%3Atop).
</Alert>

**But now there is a solution.**

User <ProfileBadge platform="GitHub" handle="ony3000">Hyeonjong</ProfileBadge> has created <ProfileBadge platform="GitHub" handle="ony3000/prettier-plugin-classnames">prettier-plugin-classnames</ProfileBadge>,
which wraps long class names based on Prettier's `printWidth` option. With a
slightly extended configuration, it can be used in conjunction with <ProfileBadge platform="GitHub" handle="tailwindlabs/prettier-plugin-tailwindcss">prettier-plugin-tailwindcss</ProfileBadge>
to also automatically sort the classes.

<Alert type="tip">
  For more information on how to get the plugin up and running, I suggest you
  read the [installation
  instructions](https://github.com/ony3000/prettier-plugin-classnames?tab=readme-ov-file#installation1).
  Basically it's just a matter of installing the plugin, adding it to your
  `prettier.config.js` and restarting your code editor.
</Alert>

I am using the plugin on this site with the following `prettier.config.js`.

```js filename="prettier.config.js" {10,12-13,15} showLineNumbers
/** @type {import("prettier").Config} */
const functions = ["cn", "clsx", "cva"];
export default {
  // Used to sort classes in strings provided to function calls (clsx, twMerge or cva)
  tailwindFunctions: functions,
  // Used to wrap classes in strings provided to function calls (clsx, twMerge or cva)
  customFunctions: functions,
  tailwindStylesheet: "./app/app.css",
  // https://github.com/ony3000/prettier-plugin-classnames?tab=readme-ov-file#ending-position
  endingPosition: "absolute-with-indent",
  plugins: [
    "prettier-plugin-tailwindcss",
    "prettier-plugin-classnames",
    // Needed to make both plugins work together
    "prettier-plugin-merge",
  ],
  semi: true,
  tabWidth: 2,
  singleQuote: false,
};
```

### Adjusting Font Size in VS Code Intellisense Extension

One of the reasons Tailwind CSS has become such a time-saving tool for me is undoubtedly the great [Intellisense extension for VS Code](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss). It gives you autosuggestions for classes, but also pixel values according to your root font size, which can be very helpful.

A common problem I ran into was that if I deviated from the default font size of 16px in my project, the pixel values displayed by the extension would not update accordingly and would always stick to the default font size of 16px.

However, after a bit of research, I found that there is an option to change the font size used by the extension to your liking using the `rootFontSize` setting.

```json filename=".vscode/settings.json" {2}
{
  "tailwindCSS.rootFontSize": 17
}
```

You should now see the correct pixel values when you hover over the classes after changing the setting.

### Automatic class sorting

Maintaining a clean and organised codebase is essential for any development project. One useful feature that improves code clarity, especially when working with Tailwind CSS, is automatic class sorting.

#### Integration with Prettier

The <ProfileBadge platform="GitHub" handle="tailwindlabs/prettier-plugin-tailwindcss">prettier-plugin-tailwindcss</ProfileBadge> automatically organises Tailwind CSS classes in your files according to a
predefined order, which not only improves readability, but also helps to
maintain a consistent style across your project.

<Alert type="tip">
  To learn more about how the classes are ordered and how to install the plugin,
  I suggest you read [the corresponding blog
  post](https://tailwindcss.com/blog/automatic-class-sorting-with-prettier).
</Alert>

#### VS Code Extension Headwind

There is also a [VS Code extension called Headwind](https://marketplace.visualstudio.com/items?itemName=heybourn.headwind) which does basically the same thing but has a different ordering system. I used it for a while before I found out about the Prettier plugin.

<Alert type="warning">
  I can't recommend using it as it's no longer maintained and there seem to be
  [some issues that won't get
  fixed](https://github.com/heybourn/headwind/issues). However there is a more
  [actively maintained fork](https://github.com/heybourn/headwind/issues/206) of
  Headwind called "Tailwind Raw Reorder", which is also [available on the Visual
  Studio
  Marketplace](https://marketplace.visualstudio.com/items?itemName=Trapfether.tailwind-raw-reorder).
</Alert>

## Design patterns

Because I find myself implementing the same design patterns in many of my projects, here are some of them.

### Break elements out of typography plugin

To ensure high quality typography standards for a project, I often rely on [Tailwind CSS's typography plugin](https://github.com/tailwindlabs/tailwindcss-typography), which provides some useful classes to get you up and running in no time.

Recently I was creating a website for a side project and to make things a bit more interesting I wanted to break out some of the elements out of the typography container. At first I thought this could be achieved by using the `not-prose` class as mentioned in [the plugins README for undoing typography styles](https://github.com/tailwindlabs/tailwindcss-typography?tab=readme-ov-file#undoing-typography-styles). However, this does not work for breaking elements out of the `prose` container that sets a `max-width`, which makes sense.

A workaround for this is to set a negative `margin` on the horizontal axis and break out elements that way.

```html /md:-mx-16 lg:-mx-32 2xl:-mx-48/ {2}
<div class="prose">
  <div class="not-prose md:-mx-16 lg:-mx-32 2xl:-mx-48">
    <!-- ... -->
  </div>
</div>
```

The result is a section that extends beyond the pluginâ€™s defined `max-width`.

<BreakoutSection />

### Create gradient text with Tailwind CSS

Many professional websites today use gradient headlines to grab the attention of visitors and give their pages a dynamic, modern look.

<GradientHeading>This is a demo text</GradientHeading>

Here is how you can implement that in one line with Tailwind CSS v4.

```html {1}
<h1 class="inline-block bg-linear-to-b from-neutral-500 to-neutral-300 bg-clip-text text-3xl text-transparent">
  This is a demo text
</h1>
```

That's all for now! Thanks for reading and I would really appreciate your feedback or hear about tips that you find worth sharing!
